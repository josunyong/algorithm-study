# 연산 3가지 ( -1, /2, /3)을 활용해서 1로만들때의 최소 연산 수)
# 정답참조 -> 처음에 초기리스트에 연산3개를 람다식으로 넣어서 표현해봤지만 연산의 "최소값"이 안나옴
# 반복문 사용
# 2와 3으로 나뉘지 않으면 -1
# 2와 3으로 나뉘면 그 연산을 사용

'''
d테이블 초기화 => 연산횟수를 저장할 테이블

for 2부터 N까지
    d[기본]=d[이전]+1  ==> /2, /3이 안된 경우 기본 값은 이전 +1

    if 2로 나뉘면
        d[i]와 d[i//2]+1 중 작은거 선택

    if 3으로 나뉘면
        d[i]와 d[i//3]+1 중 작은거 선택
'''

# dp 테이블 초기화: d[i]는 i를 1로 만드는 데 필요한 최소 연산 횟수를 저장
n=int(input())

d=[0]*(n+1) # 연산 횟수를 담을 테이블 초기화

for i in range(2,n+1): # 2부터 N까지
    d[i]=d[i-1]+1 # 아무것도 안나뉘면 -1 ==> i값은 (이전값 +1)

    if i%2==0: # 2로 나뉘면
        d[i]=min(d[i],d[i//2]+1) # 원래의 값과 2로 나눈 값중 작은 값 사용 +1은(2로 나뉘는 연산)

    if i%3==0: # 3으로 나뉘면
        d[i]=min(d[i],d[i//3]+1) # 원래의 값과 3으로 나눈 값중 작은 값 사용 +1은(3으로 나뉘는 연산)

print(d[n])



