# 처음에 저 리스트를 다 순회하면서 한칸 한칸 움직임 갱신하는 쪽으로 접근
# 움직임 표현하고 이동횟수를 count로 잡아 구현
# 근데 count>=4 일떄 움직임을 다 사용 <- 이 조건을 모르겠어서 정답참조

# 그냥 주어진 판의 크기를 생각하여 움직임을 생각
# N이 행, M이 열
# 행열의 크기로 움직이는 갯수를 제한 -> 병든 나이트가 판을 벗어날 수는 없으니까

def moving(x, y, N, M):
    # 병든 나이트의 이동 가능한 방향 (오른쪽 방향으로만 이동)
    move_list = [(-2, 1), (-1, 2), (1, 2), (2, 1)]
    count = 0  # 총 이동 횟수

    # N(행)이 1이면 한 칸에 갇혀서 움직일 수 없음 → 시작 위치만 가능
    if N == 1:
        return 1

    # N(행)이 2이면 (-1,2)또는 (1,2)만 이동 가능 → 최대 4번까지만 이동 가능
    if N == 2:
        return min(4, (M - 1) // 2 + 1) # 4번을 초과하면 움직임을 다 써야하는데 불가능 -> M이 4보다 적으면 그만큼만 움직일 수 있음, M이 4보다 크면
                                        # M-1은 0부터 시작하는 인덱스 보정, //2는 2칸씩 움직이는 것, +1은 최소 한번은 움직이기에 보정

    # M이 7 미만이면 4가지 이동 딱 다 사용하고 끝 -> 4가지 이동 사용시 열은 딱 6칸 이동
    if M < 7:
        return min(4, M) # 딱 4번 이동 하든지(열6칸 이동) 혹은 M에 맞춰 이동 횟수가 더 작던지

    # M이 7 이상이면 4가지 이동을 한 번씩 사용한 후, 2칸씩 이동 가능
    return M - 2  # (처음 4번 사용하고 나서부터는 2칸씩 이동) # 2칸씩 움직여야 최대한 많은 칸을 방문 할 수 있기 때문


# 입력 처리
N, M = map(int, input().split())  # 체스판 크기 입력
print(moving(0, 0, N, M))  # 결과 출력
